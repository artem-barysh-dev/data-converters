{
  "name": "ChirpStack Uplink Converter for ioButton",
  "type": "UPLINK",
  "integrationType": "CHIRPSTACK",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": true,
    "allEnabled": false,
    "allEnabledUntil": 1742222470791
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "// If you want to override configuration from converter you can set value instead of null to variables below.\nvar entityType = null; // Entity type allows you to choose type of created entity. Can be DEVICE or ASSET.\nvar name = null; // Device or asset name.\nvar profile = null; // Device or asset profile name.\nvar group = null; // If group is not null - created entity will be added to the entity group with such name.\nvar customer = null; // If customer is not null - created entity will be assigned to customer with such name.\n\n// If you want to parse incoming data somehow, you can add your code to decodePayload function.\n// input: bytes\n// Note ts represents a timestamp in milliseconds since the Unix epoch (January 1, 1970)\n// expected output:\n//  {\n//    \"attributes\": {\"attributeKey\": \"attributeValue\"},\n//    \"telemetry\": [{\"ts\": 1730898982391, \"values\": {\"telemetryKey\":\"telemetryValue\"}, {\"ts\": 1730518182391, \"values\": {\"telemetryKey\":\"telemetryValue\"}}]\n//  }\n\nfunction decodePayload(input) {\n    var output = {\n        attributes: {},\n        telemetry: []\n    };\n\n    // --- Timestamp parsing\n    var dateString = metadata.time;\n    timestamp = parseDateToTimestamp(dateString);\n    // --- Timestamp parsing\n\n    // --- Decoding code --- //\n    var decoded = {};\n    var index = 0;\n    var headerByte = input[index++];\n    output.attributes.uplinkReasonButton = ((headerByte & 1) != 0);\n\n    if (output.attributes.uplinkReasonButton) {\n        output.attributes.buttonClickReason = 'single';\n    }\n    \n    output.attributes.uplinkReasonMovement = ((headerByte & 2) != 0);\n    output.attributes.uplinkReasonGpio = ((headerByte & 4) != 0);\n    output.attributes.containsGps = ((headerByte & 8) != 0);\n    output.attributes.containsOnboardSensors = ((headerByte & 16) != 0);\n    output.attributes.containsSpecial = ((headerByte & 32) != 0);\n    output.attributes.crc = Integer.toHexString(input[index++] & 0xFF);\n    decoded.batteryLevel = parseBytesIntToFloat(input, index, 1);\n    index += 1;\n    \n    if (output.attributes.containsOnboardSensors != null && output.attributes.containsOnboardSensors) {\n        var sensorContent = input[index++];\n        output.attributes.containsTemperature = ((sensorContent & 1) != 0);\n        output.attributes.containsLight = ((sensorContent & 2) != 0);\n        output.attributes.containsAccelerometerCurrent = ((sensorContent & 4) != 0);\n        output.attributes.containsAccelerometerMax = ((sensorContent & 8) != 0);\n        output.attributes.containsWifiPositioningData = ((sensorContent & 16) != 0);\n        output.attributes.buttonEventInfo = ((sensorContent & 32) != 0);\n        output.attributes.containsExternalSensors = ((sensorContent & 64) != 0);\n        output.attributes.containsBluetoothData = false;\n        \n        var buttonHeader = output.attributes.uplinkReasonButton;\n        var buttonEvent = output.attributes.buttonEventInfo;\n        if (!buttonEvent && !buttonHeader) {\n          output.attributes.buttonClickReason = 'none';\n        } else if (!buttonEvent && buttonHeader) {\n          output.attributes.buttonClickReason = 'single';\n        } else if (buttonEvent && !buttonHeader) {\n          output.attributes.buttonClickReason = 'long';\n          output.attributes.uplinkReasonButton = true;\n        } else if (buttonEvent && buttonHeader) {\n          output.attributes.buttonClickReason = 'double';\n        }\n        \n        var hasSecondSensorContent = (sensorContent & 128) != 0;\n\n        if (hasSecondSensorContent) {\n          var sensorContent2 = input[index++];\n          output.attributes.containsBluetoothData = (sensorContent2 & 1) != 0;\n          output.attributes.containsRelativeHumidity = (sensorContent2 & 2) != 0;\n          output.attributes.containsAirPressure = (sensorContent2 & 4) != 0;\n          output.attributes.containsManDown = (sensorContent2 & 8) != 0;\n          output.attributes.containsTilt = (sensorContent2 & 16) != 0;\n          output.attributes.containsRetransmitCnt = (sensorContent2 & 32) != 0;\n        }\n        \n        if (output.attributes.containsTemperature) {\n          decoded.temperature = parseBytesToInt(input, index, 2) / 100;\n          index += 2;\n        }\n    \n        if (output.attributes.containsLight != null && output.attributes.containsLight) {\n          var value = parseBytesToInt(input, index, 2);\n          var exponent = value >> 12 & 0xFF;\n          decoded.lightIntensity = Float.valueOf((value & 0x0FFF) << exponent) / 100;\n          index += 2;\n        }\n        \n        if (output.attributes.containsAccelerometerCurrent != null && output.attributes.containsAccelerometerCurrent) {\n          decoded.accelerometer = {\n            x: parseBytesIntToFloat(input, index, 2) / 1000,\n            y: parseBytesIntToFloat(input, index + 2, 2) / 1000,\n            z: parseBytesIntToFloat(input, index + 4, 2) / 1000\n          };\n          \n          input += 6;\n        }\n    \n        if (output.attributes.containsAccelerometerMax != null && output.attributes.containsAccelerometerMax) {\n          decoded.maxAccelerationNew = parseBytesIntToFloat(input, index, 2) / 1000;\n          decoded.maxAccelerationHistory = parseBytesIntToFloat(input, index + 2, 2) / 1000;\n          \n          input += 4;\n        }\n        \n        if(output.attributes.containsWifiPositioningData != null && output.attributes.containsWifiPositioningData) {\n            var wifiInfo = input[index++];\n            var numAccessPoints = wifiInfo & 7;\n             \n            var wifiStatus = ((wifiInfo & 8) >> 2) + ((wifiInfo & 16) >> 3);\n             var containsSignalStrength = wifiInfo & 32;\n             var wifiStatusDescription = \"\";\n        \n            switch (wifiStatus) {\n                case 0:\n                  wifiStatusDescription = 'success';\n                  break;\n                case 1:\n                  wifiStatusDescription = 'failed';\n                  break;\n                case 2:\n                  wifiStatusDescription = 'no_access_points';\n                  break;\n        \n                default:\n                  wifiStatusDescription = \"unknown (\" + wifiStatus + \")\";\n            }\n            \n            decoded.wifiInfo = {\n                status: wifiStatusDescription,\n                statusCode: wifiStatus,\n                accessPoints: []\n            };\n            \n            for (int i = 0; i < numAccessPoints; i++) {\n                var macParts = [];\n                for (int j = 0; j < 6; j++) {\n                    macParts[j] = String.format(\"%02x\", input[index++] & 0xFF);\n                }\n                var macAddress = String.join(\":\", macParts);\n                \n                var signalStrength = null;\n                if (containsSignalStrength != 0) {\n                    signalStrength = input[index++];\n                }\n                \n                decoded.wifiInfo.accessPoints.push({\n                    macAddress: macAddress,\n                    signalStrength: signalStrength\n                });\n            }\n        }\n        \n        if (output.attributes.containsExternalSensors != null && output.attributes.containsExternalSensors) {\n            var type = input[index++];\n            \n            if (type === 0x0A) {\n              decoded.externalSensor = {\n                type: 'battery',\n                batteryA: parseBytesToInt(input, index, 2),\n                batteryB: parseBytesToInt(input, index + 2, 2)\n              };\n              i += 4;\n            } else if (type === 0x64) {\n              decoded.externalSensor = {\n                type: 'externalTemperature',\n                value: parseBytesToInt(input, index, 2) / 100\n              };\n              i += 2;\n            } else if (type === 0x65) {\n              decoded.externalSensor = {\n                type: 'detectSwitch',\n                value: input[index++]\n              };\n            } else if (type === 0x66) {\n                var iobuttonStateData = input[index++];\n                var iobuttonState = (iobuttonStateData & 0xF0) >> 4;\n                var iobuttonStateClickCnt = iobuttonStateData & 0x0F;\n                \n                if (iobuttonState === 0) {\n                    iobuttonState = 'Idle';\n                } else if (iobuttonState === 1) {\n                    iobuttonState = 'Calling';\n                } else if (iobuttonState === 2) {\n                    iobuttonState = 'Success';\n                } else if (iobuttonState === 3) {\n                    iobuttonState = 'Cleared';\n                } else {\n                    iobuttonState = 'Undefined';\n                }\n\n                decoded.externalSensor = {\n                    type: 'buttonState',\n                    state: iobuttonState,\n                    clickCnt: iobuttonStateClickCnt\n                };\n            }\n        }\n        \n        if(output.attributes.containsBluetoothData != null && output.attributes.containsBluetoothData) {\n            var bluetoothInfo = input[index++];\n            var numBeacons = bluetoothInfo & 7;\n            var bluetoothStatus = bluetoothInfo >> 3 & 0x03;\n            var addSlotInfo = bluetoothInfo >> 5 & 0x03;\n            var bluetoothStatusDescription = \"\";\n            \n            if (bluetoothStatus == 0) {\n                bluetoothStatusDescription = \"success\";\n            }\n            else if (bluetoothStatus == 1) {\n                bluetoothStatusDescription = \"failed\";\n            }\n            else if (bluetoothStatus == 2) {\n                bluetoothStatusDescription = \"no_access_points\";\n            }\n            else {\n                bluetoothStatusDescription = \"unknown (\" + bluetoothStatus + \")\";\n            }\n            \n            decoded.bluetoothInfo = {\n                status: bluetoothStatusDescription,\n                statusCode: bluetoothStatus,\n                addSlotInfo: addSlotInfo,\n                beacons: []\n            };\n            \n            for (var i = 0; i < numBeacons; i++) {\n                var beaconBluetoothBeaconsResult = null;\n                if (addSlotInfo == 0x00) {\n                    beaconBluetoothBeaconsResult = parseBluetoothBeacons00();\n                }\n                else if (addSlotInfo == 0x01) {\n                    beaconBluetoothBeaconsResult = parseBluetoothBeacons01();\n                }\n                else if (addSlotInfo == 0x02) {\n                    beaconBluetoothBeaconsResult = parseBluetoothBeacons02();\n                }\n                \n                if (beaconBluetoothBeaconsResult != null) {\n                    decoded.bluetoothInfo.beacons.push(beaconBluetoothBeaconsResult.beacon);\n                    index += beaconBluetoothBeaconsResult.index;\n                }\n            }\n        }\n        \n        if (output.attributes.containsRelativeHumidity != null && output.attributes.containsRelativeHumidity) {\n           decoded.relativeHumidity = parseBytesToInt(input, index, 2) / 100;\n           i += 2;\n        }\n    \n        if (output.attributes.containsAirPressure != null && output.attributes.containsAirPressure) {\n           decoded.airPressure = parseBytesToInt(input, index, 3);\n           i += 3;\n        }\n        \n        if (output.attributes.containsManDown != null && output.attributes.containsManDown) {\n           var manDownData = (input[index++]);\n           var manDownState = (manDownData & 0x0f);\n           var manDownStateLabel = \"\";\n          \n           if (manDownState === 0x00) {\n               manDownStateLabel = 'ok';\n           } else if (manDownState === 0x01) {\n               manDownStateLabel = 'sleeping';\n           } else if (manDownState === 0x02) {\n               manDownStateLabel = 'preAlarm';\n           } else if (manDownState === 0x03) {\n               manDownStateLabel = 'alarm';\n           } else {\n               manDownStateLabel = manDownState + '';\n           }\n\n           decoded.manDown = {\n               state: manDownStateLabel,\n               positionAlarm: (manDownData & 0x10) != 0,\n               movementAlarm: (manDownData & 0x20) != 0\n           };\n        }\n        \n        if (output.attributes.containsTilt != null && output.attributes.containsTilt) {\n            decoded.tilt = {\n              currentTilt: parseBytesToInt(input, index, 2) / 100,\n              currentDirection: Math.round(input[index + 2] * (360/255)),\n              maximumTiltHistory: parseBytesToInt(input, index + 3, 2) / 100,\n              DirectionHistory: Math.round(input[index + 5] * (360/255)),\n            };\n            index += 6;\n        }\n\n        if (output.attributes.containsRetransmitCnt != null && output.attributes.containsRetransmitCnt) {\n            decoded.retransmitCnt = input[index++];\n            index += 1;\n        }\n    }\n    \n    if (output.attributes.containsGps != null && output.attributes.containsGps) {\n        decoded.gps = {};\n        decoded.gps.navStat = input[index++];\n        decoded.gps.latitude = parseBytesIntToFloat(input, index, 4) / 10000000;\n        decoded.gps.longitude = parseBytesIntToFloat(input, index + 4, 4) / 10000000;\n        decoded.gps.altRef = parseBytesIntToFloat(input, index + 8, 2) / 10;\n        decoded.gps.hAcc = input[index + 10];\n        decoded.gps.vAcc = input[index + 11];\n        decoded.gps.sog = parseBytesIntToFloat(input, index + 12, 2) / 10;\n        decoded.gps.cog = parseBytesIntToFloat(input, index + 14, 2) / 10;\n        decoded.gps.hdop = input[index + 16] / 10;\n        decoded.gps.numSvs = input[index + 17];\n        index += 18;\n    }\n\n    output.telemetry = [{\n        ts: timestamp,\n        values: decoded\n    }];\n\n    // --- Decoding code --- //\n    return output;\n}\n\n// --- attributes and telemetry objects ---\nvar telemetry = [];\nvar attributes = {};\n// --- attributes and telemetry objects ---\n\nvar customDecoding = decodePayload(base64ToBytes(bytesToString(payload)));\n\n// Collecting data to result\nif (customDecoding.?telemetry.size() > 0) {\n    if (customDecoding.telemetry instanceof java.util.ArrayList) {\n        foreach(telemetryObj: customDecoding.telemetry) {\n            if (telemetryObj.ts != null && telemetryObj.values != null) {\n                telemetry.add(telemetryObj);\n            }\n        }\n    } else {\n        telemetry.putAll(customDecoding.telemetry);\n    }\n}\n\nif (customDecoding.?attributes.size() > 0) {\n    attributes.putAll(customDecoding.attributes);\n}\n\nvar result = {\n    type: entityType,\n    name: name,\n    profile: profile,\n    customer: customer,\n    group: group,\n\n    attributes: attributes,\n    telemetry: telemetry\n};\n\nreturn result;\n\nfunction parseDateToTimestamp(dateString) {\n    var date = new Date(dateString);\n    var timestamp = date.getTime();\n\n    // If we cannot parse timestamp - we will use the current timestamp\n    if (timestamp == -1) {\n        timestamp = Date.now();\n    }\n\n    return timestamp;\n}",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "eui",
      "devAddr",
      "fPort",
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "adr",
      "dr",
      "frequency",
      "bandwidth",
      "spreadingFactor",
      "codeRate"
    ],
    "type": "DEVICE",
    "name": "Device $eui",
    "profile": "$deviceProfileName",
    "label": "$deviceName",
    "customer": "",
    "group": "",
    "telemetry": null,
    "attributes": [
      "eui",
      "devAddr",
      "fPort",
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "adr",
      "dr",
      "frequency",
      "bandwidth",
      "spreadingFactor",
      "codeRate"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false,
  "converterVersion": 2
}