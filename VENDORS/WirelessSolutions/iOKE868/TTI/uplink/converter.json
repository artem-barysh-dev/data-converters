{
  "name": "Things Stack Industries Uplink Converter for Wireless Solutions iOKE868",
  "type": "UPLINK",
  "integrationType": "TTI",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": true,
    "allEnabled": false,
    "allEnabledUntil": 0
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "/**\n * Decodes the incoming payload and returns a structured object containing telemetry data and attributes.\n *\n * @param {byte[]} input - The raw payload received as an array of bytes.\n * @returns {Object} output - The structured output with decoded telemetry and attributes.\n */\n \nvar VERSION_LOG = \"use of payload parser V1.19 for 'IMST iO881A for LoRaWAN®'\";\nvar PORT_SEGMENTATION_BIT = 0x40;\nvar STATUS_PORT = 0x03;\nvar STATUS_PORT_SEGMENTED = PORT_SEGMENTATION_BIT | STATUS_PORT;\nvar METER_VALUE_PORT = 0x05;\nvar METER_VALUE_PORT_SEGMENTED = PORT_SEGMENTATION_BIT | METER_VALUE_PORT;\nvar SEGMENTED_WARNING = \"WARNING: decoding of segmented payload - values can be incorrect or incomplete\";\n\nvar TYPE_MASK = 0xF0;\nvar SUB_TYPE_MASK = 0x0F;\nvar INFO_TYPE = 0x00;\nvar METER_ID_TYPE = 0x10;\nvar OBJECT_TYPE = 0x40;\n\nvar ERROR_METER_DATA = \"ERROR: unable to decode meter data: hex \";\nvar ERROR_STATUS_FIELD = \"ERROR: unable to decode status field: hex \";\nvar ERROR_TIME_FIELD = \"ERROR: unable to decode time field: hex \";\nvar ERROR_METER_ID = \"ERROR: unable to decode meter ID: hex \";\nvar ERROR_OBJECT_FIELD = \"ERROR: unable to decode meter object field: hex \";\n\nvar INFO_STATUS_TYPE = 0x00;\nvar INFO_TIME_TYPE = 0x01;\nvar POWER_PHASE_TOTAL_TYPE = 0x00;\nvar POWER_PHASE_L1_TYPE = 0x01;\nvar POWER_PHASE_L2_TYPE = 0x02;\nvar POWER_PHASE_L3_TYPE = 0x03;\nvar OBJECT_WITH_UNIT = 0x00;\nvar OBJECT_WITHOUT_UNIT = 0x01;\nvar OBJECT_WITH_STRING = 0x02;\n\nvar STATUS_FIELD_HEADER_SIZE = 2;\nvar STATUS_FIELD_PAYLOAD_SIZE = 2;\nvar STATUS_FIELD_INFO_METER_TYPE_MASK = 0x3;\nvar STATUS_FIELD_INFO_INPUT_TYPE_MASK = 0x1C;\nvar STATUS_FIELD_INFO_INPUT_TYPE_SHIFT = 2;\nvar STATUS_INFO_INPUT_TYPE_UNKNOWN = 0;\nvar STATUS_INFO_INPUT_TYPE_IEC_A = 1;\nvar STATUS_INFO_INPUT_TYPE_IEC_B = 2;\nvar STATUS_INFO_INPUT_TYPE_IEC_C = 3;\nvar STATUS_INFO_INPUT_TYPE_IEC_D = 4;\nvar STATUS_INFO_INPUT_TYPE_SML = 6;\nvar STATUS_FIELD_OK = 0;\nvar STATUS_FIELD_NO_INPUT = 1;\nvar STATUS_FIELD_INPUT_FILE_ERROR = 2;\nvar STATUS_FIELD_INPUT_FILE_INCOMPLETE = 3;\nvar STATUS_FIELD_UNKNOWN_METER_ID = 4;\nvar STATUS_FIELD_NO_FILTERED_DATA = 5;\nvar STATUS_INFO_METER_TYPE_UNKNOWN = 0;\nvar STATUS_INFO_METER_TYPE_IMPORT = 1;\nvar STATUS_INFO_METER_TYPE_EXPORT = 2;\nvar STATUS_INFO_METER_TYPE_IMPORT_EXPORT = 3;\n\nvar TIME_FIELD_HEADER_SIZE = 2;\nvar TIME_FIELD_PAYLOAD_SIZE = 4;\n\nvar METER_FIELD_HEADER_SIZE = 2;\n\nvar OBJECT_WITH_ID_FIELD_HEADER_SIZE = 4;\nvar OBJECT_WITH_ID_FIELD_TYPE_INDEX = 0;\nvar OBJECT_WITH_ID_FIELD_LENGTH_INDEX = 1;\nvar OBJECT_WITH_ID_FIELD_GROUP_MASK_INDEX = 2;\nvar OBJECT_WITH_ID_FIELD_OBIS_ID_INDEX = 3;\nvar OBJECT_WITH_ID_FIELD_SCALER_INDEX_DEPENDENT_OBIS_ID = 0;\nvar OBJECT_WITH_ID_FIELD_MANTISSA_INDEX_DEPENDENT_OBIS_ID = 1;\n\nvar OBJECT_ID_AND_UNIT_FIELD_HEADER_SIZE = 5;\nvar OBJECT_ID_AND_UNIT_FIELD_TYPE_INDEX = 0;\nvar OBJECT_ID_AND_UNIT_FIELD_LENGTH_INDEX = 1;\nvar OBJECT_ID_AND_UNIT_FIELD_GROUP_MASK_INDEX = 2;\nvar OBJECT_ID_AND_UNIT_FIELD_OBIS_ID_INDEX = 3;\nvar OBJECT_ID_AND_UNIT_FIELD_UNIT_INDEX_DEPENDENT_OBIS_ID = 0;\nvar OBJECT_ID_AND_UNIT_FIELD_SCALER_INDEX_DEPENDENT_OBIS_ID = 1;\nvar OBJECT_ID_AND_UNIT_FIELD_MANTISSA_INDEX_DEPENDENT_OBIS_ID = 2;\n\nvar OBJECT_WITH_STRING_HEADER_SIZE = 3;\nvar OBJECT_WITH_STRING_TYPE_INDEX = 0;\nvar OBJECT_WITH_STRING_LENGTH_INDEX = 1;\nvar OBJECT_WITH_STRING_GROUP_MASK_INDEX = 2;\nvar OBJECT_WITH_STRING_OBIS_ID_INDEX = 3;\n\nvar OBIS_ID_GROUP_A = ( 1 << 7 );\nvar OBIS_ID_GROUP_B = ( 1 << 6 );\nvar OBIS_ID_GROUP_C = ( 1 << 5 );\nvar OBIS_ID_GROUP_D = ( 1 << 4 );\nvar OBIS_ID_GROUP_E = ( 1 << 3 );\nvar OBIS_ID_GROUP_F = ( 1 << 2 );\n\nvar OBIS_IDS_NAME = \"OBIS_IDs\";\nvar INFO_NAME = \"general_info\";\nvar INFO_LOG_NAME = \"info_log\";\nvar OBIS_ID_DELIMITER = \"_\";\n\nvar dlmsUnits = {\n    1: 'a',\n    2: 'mo',\n    3: 'wk',\n    4: 'd',\n    5: 'h',\n    6: 'min.',\n    7: 's',\n    8: '°',\n    9: '°C',\n    10: 'currency',\n    11: 'm',\n    12: 'm/s',\n    13: 'm³',\n    14: 'm³',\n    15: 'm³/h',\n    16: 'm³/h',\n    17: 'm³/d',\n    18: 'm³/d',\n    19: 'l',\n    20: 'kg',\n    21: 'N',\n    22: 'Nm',\n    23: 'Pa',\n    24: 'bar',\n    25: 'J',\n    26: 'J/h',\n    27: 'W',\n    28: 'VA',\n    29: 'var',\n    30: 'Wh',\n    31: 'VAh',\n    32: 'varh',\n    33: 'A',\n    34: 'C',\n    35: 'V',\n    36: 'V/m',\n    37: 'F',\n    38: 'Ω',\n    39: 'Ωm²/m',\n    40: 'Wb',\n    41: 'T',\n    42: 'A/m',\n    43: 'H',\n    44: 'Hz',\n    45: '1/(Wh)',\n    46: '1/(varh)',\n    47: '1/(VAh)',\n    48: 'V²h',\n    49: 'A²h',\n    50: 'kg/s',\n    51: 'S, mho',\n    52: 'K',\n    53: '1/(V²h)',\n    54: '1/(A²h)',\n    55: '1/m³',\n    56: '%',\n    57: 'Ah',\n    60: 'Wh/m³',\n    61: 'J/m³',\n    62: 'Mol %',\n    63: 'g/m³',\n    64: 'Pa s',\n    253: '',\n    254: '',\n    255: ''\n};\n\nfunction decodePayload(input) {\n    var result = {attributes: {}, telemetry: {}};\n\n    var timestamp = metadata.ts;\n    var port = metadata.fPort;\n    var infoLog = null;\n\n    var values = {};\n    var fun_result = null;\n    \n    if (port == METER_VALUE_PORT_SEGMENTED || port == METER_VALUE_PORT) {\n        if (port == METER_VALUE_PORT_SEGMENTED) {\n            input = input.slice(1);\n            infoLog = SEGMENTED_WARNING;\n        }\n        result = decodeIRReaderPayload(input);\n    } else if (port == STATUS_PORT_SEGMENTED || port == STATUS_PORT) {\n        if (port == STATUS_PORT_SEGMENTED) {\n            input = input.slice(1);\n            infoLog = SEGMENTED_WARNING;\n        }\n        result = decodeStatusPayload(input);\n    }\n    \n    result.attributes[INFO_LOG_NAME] = [];\n    result.attributes[INFO_LOG_NAME].push(VERSION_LOG);\n    \n    if (infoLog != null) {\n        result.attributes[INFO_LOG_NAME].push(infoLog);\n    }\n\n    return result;\n}\n\nfunction decodeIRReaderPayload(bytes) {\n    var pos = 0;\n    var attributes = {};\n    var telemetry  = {};\n    var decodeErrors = [];\n    var retArray = {};\n\n    if ((pos + 2) >= bytes.length) {\n        return logDecodeError(\n            { attributes: attributes, telemetry: telemetry },\n            bytes, pos, [], ERROR_METER_DATA\n        );\n    }\n\n    while ((pos + 2) <= bytes.length) {\n        var type       = (bytes[pos]       & 0xFF);\n        var typeLength = (bytes[pos + 1]   & 0xFF);\n        var mainType   = (type & TYPE_MASK);\n\n        if (mainType == INFO_TYPE) {\n            var subType = (type & SUB_TYPE_MASK);\n            if (subType == INFO_STATUS_TYPE) {\n                retArray = decodeStatus(bytes, pos);\n                if (retArray.length >= 6) {\n                    attributes.info_byte             = retArray[1];\n                    attributes.status_byte           = retArray[2];\n                    attributes.input_type            = retArray[3];\n                    attributes.meter_type            = retArray[4];\n                    attributes.infrared_input_status = retArray[5];\n                    if (retArray.length > 6) {\n                        attributes.further_status = retArray[6];\n                    }\n                } else {\n                    decodeErrors.add(\"STATUS decode error at pos \" + pos);\n                }\n\n            } else if (subType == INFO_TIME_TYPE) {\n                retArray = decodeTime(bytes, pos);\n                if (retArray.length >= 2) {\n                    var ts = (retArray[1] >>> 0) * 1000;\n                    attributes.Time        = new Date(ts).toString();\n                    attributes.Time_Origin = \"device time\";\n                } else {\n                    decodeErrors.add(\"TIME decode error at pos \" + pos);\n                }\n\n            } else {\n                decodeErrors.add(\"unsupported INFO sub-type: 0x\" + intToHex(type));\n            }\n\n        } else if (mainType == METER_ID_TYPE) {\n            retArray = decodeMeterID(bytes, pos);\n            if (retArray.length > 1) {\n                attributes.meter_id = retArray[1];\n            } else {\n                decodeErrors.add(\"METER_ID decode error at pos \" + pos);\n            }\n\n        } else if (mainType == OBJECT_TYPE) {\n            var subType = (type & SUB_TYPE_MASK);\n            if (subType == OBJECT_WITH_UNIT) {\n                retArray = decodeObjectWithIDAndUnitField(bytes, pos);\n            } else if (subType == OBJECT_WITHOUT_UNIT) {\n                retArray = decodeObjectWithIDField(bytes, pos);\n            } else if (subType == OBJECT_WITH_STRING) {\n                retArray = decodeObjectWithString(bytes, pos);\n            } else {\n                decodeErrors.add(\"unsupported OBJECT sub-type: 0x\" + intToHex(type));\n            }\n\n            if (retArray != null && retArray.length >= 6) {\n                var obisID = retArray[1];\n                var scaler = retArray[4];\n                if ((scaler & 0x80) == 0x80) { scaler -= 0x100; }\n                var raw   = retArray[5];\n                var value = raw * Math.pow(10, scaler);\n                telemetry[obisID] = parseFloat(value.toFixed(scaler < 0 ? -scaler : 0));\n            } else {\n                decodeErrors.add(\"OBJECT decode error at pos \" + pos);\n            }\n\n        } else {\n            decodeErrors.add(\"unsupported type: 0x\" + intToHex(type));\n        }\n\n        pos += 2 + typeLength;\n        if ((pos + 2) > bytes.length && pos < bytes.length) {\n            decodeErrors.add(\"incomplete data at end of payload\");\n        }\n    }\n\n    if (decodeErrors.length > 0) {\n        attributes.decodeErrors = decodeErrors;\n    }\n\n    return {\n        attributes: attributes,\n        telemetry: telemetry\n    };\n}\n\nfunction logDecodeError(results, bytes, pos, retArray, errorMessage) {\n    var sliceEnd = (retArray.length == 1)\n        ? pos + 2 + retArray[0]\n        : bytes.length;\n    var sliceBytes = bytes.slice(pos, sliceEnd);\n    var hexParts = [];\n    for (var i = 0; i < sliceBytes.length; i++) {\n        var b   = sliceBytes[i] & 0xFF;\n        var hex = intToHex(b);\n        if (hex.length() < 2) {\n            hex = '0' + hex;\n        }\n        hexParts.add(hex);\n    }\n    var byteString = hexParts.join('-');\n    results[INFO_LOG_NAME].add(errorMessage + byteString);\n    return results;\n}\n\nfunction decodeStatus(bytes, pos) {\n    if ((bytes.length - pos) >= STATUS_FIELD_HEADER_SIZE) {\n        pos = pos + 1;\n        var length = bytes[pos];\n        pos = pos + 1;\n        if ((length >= STATUS_FIELD_PAYLOAD_SIZE) && (bytes.length >= (length + pos))) {\n            var info   = bytes[pos]; pos = pos + 1;\n            var status = bytes[pos]; pos = pos + 1;\n\n            var infraredInputStatus = \"unknown\";\n            if (status == STATUS_FIELD_OK) {\n                infraredInputStatus = \"ok\";\n            } else if (status == STATUS_FIELD_NO_INPUT) {\n                infraredInputStatus = \"no input\";\n            } else if (status == STATUS_FIELD_INPUT_FILE_ERROR) {\n                infraredInputStatus = \"input file error\";\n            } else if (status == STATUS_FIELD_INPUT_FILE_INCOMPLETE) {\n                infraredInputStatus = \"input file incomplete\";\n            } else if (status == STATUS_FIELD_UNKNOWN_METER_ID) {\n                infraredInputStatus = \"pairing error, meter ID doesn't match\";\n            } else if (status == STATUS_FIELD_NO_FILTERED_DATA) {\n                infraredInputStatus = \"no filtered data\";\n            }\n\n            var inputTypeCode = ((info & STATUS_FIELD_INFO_INPUT_TYPE_MASK) >> STATUS_FIELD_INFO_INPUT_TYPE_SHIFT);\n            var inputType = \"unknown protocol\";\n            if (inputTypeCode == STATUS_INFO_INPUT_TYPE_IEC_A) {\n                inputType = \"IEC Mode A\";\n            } else if (inputTypeCode == STATUS_INFO_INPUT_TYPE_IEC_B) {\n                inputType = \"IEC Mode B\";\n            } else if (inputTypeCode == STATUS_INFO_INPUT_TYPE_IEC_C) {\n                inputType = \"IEC Mode C\";\n            } else if (inputTypeCode == STATUS_INFO_INPUT_TYPE_IEC_D) {\n                inputType = \"IEC Mode D\";\n            } else if (inputTypeCode == STATUS_INFO_INPUT_TYPE_SML) {\n                inputType = \"SML\";\n            }\n\n            var meterTypeMask = (info & STATUS_FIELD_INFO_METER_TYPE_MASK);\n            var meterType = \"unknown\";\n            if (meterTypeMask == STATUS_INFO_METER_TYPE_IMPORT) {\n                meterType = \"import\";\n            } else if (meterTypeMask == STATUS_INFO_METER_TYPE_EXPORT) {\n                meterType = \"export\";\n            } else if (meterTypeMask == STATUS_INFO_METER_TYPE_IMPORT_EXPORT) {\n                meterType = \"import + export\";\n            }\n\n            if (length > STATUS_FIELD_PAYLOAD_SIZE) {\n                var further = bytes.slice(pos, pos + length - STATUS_FIELD_HEADER_SIZE);\n                return [length, info, status, inputType, meterType, infraredInputStatus, further];\n            } else {\n                return [length, info, status, inputType, meterType, infraredInputStatus];\n            }\n        }\n        return [length];\n    }\n\n    return [];\n}\n\nfunction decodeTime(bytes, pos) {\n    if (bytes.length >= pos + TIME_FIELD_HEADER_SIZE) {\n        pos = pos + 1;\n        var length = (bytes[pos] & 0xFF);\n        pos = pos + 1;\n        if (length == TIME_FIELD_PAYLOAD_SIZE && bytes.length >= pos + length) {\n            var timeBuffer = bytes.slice(pos, pos + 4);\n            var time = (\n                ((timeBuffer[0] & 0xFF) << 24) |\n                ((timeBuffer[1] & 0xFF) << 16) |\n                ((timeBuffer[2] & 0xFF) << 8)  |\n                (timeBuffer[3] & 0xFF)\n            ) >>> 0;\n            return [length, time];\n        }\n        return [length];\n    }\n    return [];\n}\n\nfunction decodeMeterID(bytes, pos) {\n    if (bytes.length < pos + METER_FIELD_HEADER_SIZE) {\n        return [];\n    }\n    \n    pos = pos + 1;\n    var length = bytes[pos] & 0xFF;\n    pos = pos + 1;\n    if (bytes.length < pos + length) {\n        return [length];\n    }\n    \n    var idBytes = new byte[length];\n    for (int i = 0; i < length; i++) {\n        idBytes[i] = bytes[pos + i];\n    }\n    var hexParts = [];\n    foreach ( b : idBytes) {\n        var h = Integer.toHexString(b & 0xFF).toUpperCase();\n        if (h.length() < 2) {\n            h = \"0\" + h;\n        }\n        hexParts.add(h);\n    }\n    \n    var hexString = String.join(\"-\", hexParts);\n    var asciiString = \"\";\n    for (byte b : idBytes) {\n        if (b >= 0x20 && b <= 0x7E) {\n            asciiString += (char) b;\n        }\n    }\n    \n    var meterIDString = asciiString.isEmpty()\n            ? hexString\n            : hexString + \" (\" + asciiString + \")\";\n    return [length, meterIDString];\n}\n\nfunction decodeObjectWithIDAndUnitField (bytes, pos)\n{\n    return decodeObject (bytes, pos, OBJECT_ID_AND_UNIT_FIELD_HEADER_SIZE, OBJECT_ID_AND_UNIT_FIELD_TYPE_INDEX,\n        OBJECT_ID_AND_UNIT_FIELD_LENGTH_INDEX, OBJECT_ID_AND_UNIT_FIELD_OBIS_ID_INDEX,\n        OBJECT_ID_AND_UNIT_FIELD_GROUP_MASK_INDEX, OBJECT_ID_AND_UNIT_FIELD_UNIT_INDEX_DEPENDENT_OBIS_ID,\n        OBJECT_ID_AND_UNIT_FIELD_SCALER_INDEX_DEPENDENT_OBIS_ID, OBJECT_ID_AND_UNIT_FIELD_MANTISSA_INDEX_DEPENDENT_OBIS_ID);\n}\n\nfunction decodeObjectWithIDField (bytes, pos)\n{\n    return decodeObject (bytes, pos, OBJECT_WITH_ID_FIELD_HEADER_SIZE, OBJECT_WITH_ID_FIELD_TYPE_INDEX,\n        OBJECT_WITH_ID_FIELD_LENGTH_INDEX, OBJECT_WITH_ID_FIELD_OBIS_ID_INDEX, OBJECT_WITH_ID_FIELD_GROUP_MASK_INDEX,\n        -1, OBJECT_WITH_ID_FIELD_SCALER_INDEX_DEPENDENT_OBIS_ID, OBJECT_WITH_ID_FIELD_MANTISSA_INDEX_DEPENDENT_OBIS_ID);\n}\n\nfunction decodeObjectWithString (bytes, pos)\n{\n    return decodeObject (bytes, pos, OBJECT_WITH_STRING_HEADER_SIZE, OBJECT_WITH_STRING_TYPE_INDEX,\n            OBJECT_WITH_STRING_LENGTH_INDEX, OBJECT_WITH_STRING_OBIS_ID_INDEX, OBJECT_WITH_STRING_GROUP_MASK_INDEX,\n            -1, -1, -1);\n}\n\nfunction decodeObject(bytes, pos, headerSize, typeIndex, lengthIndex, obisIDIndex, groupMaskIndex, unitIndexDependentObisID, scalerIndexDependentObisID, mantissaIndexDependentObisID) {\n    if (bytes.length >= pos + headerSize) {\n        var type   = (bytes[pos + typeIndex]   & 0xFF);\n        var length = (bytes[pos + lengthIndex] & 0xFF);\n        if (bytes.length >= pos + lengthIndex + length) {\n            var groupMask = (bytes[pos + groupMaskIndex] & 0xFF);\n            var obisInfo  = resolveObisID(groupMask, bytes, obisIDIndex, pos);\n            var obisID        = obisInfo.obisID;\n            var obisIDLength  = obisInfo.obisIDLength;\n            if (length > obisIDLength + 1 && obisID != null) {\n                var subLength = 2;\n                var unit      = -1;\n                var unitPos   = pos + 3 + obisIDLength + unitIndexDependentObisID;\n                if (unitIndexDependentObisID >= 0 && bytes.length > unitPos) {\n                    unit = (bytes[unitPos] & 0xFF);\n                    subLength++;\n                }\n                var scalerPos   = pos + 3 + obisIDLength + scalerIndexDependentObisID;\n                if (scalerIndexDependentObisID >= 0 && bytes.length > scalerPos) {\n                    var scaler = (bytes[scalerPos] & 0xFF);\n                    var mantissa = 0;\n                    var mantissaPos = pos + obisIDIndex + obisIDLength + mantissaIndexDependentObisID;\n                    if (bytes.length >= pos + groupMaskIndex + length && (pos + groupMaskIndex + length) >= mantissaPos) {\n                        var payloadLen = length - obisIDLength - subLength;\n                        mantissa = getInt64(bytes, mantissaPos, payloadLen);\n                        return [length, obisID, groupMask, unit, scaler, mantissa];\n                    }\n                } else {\n                    var strStart = pos + 3 + obisIDLength;\n                    var strEnd   = pos + 2 + length;\n                    var stringBuffer = bytes.slice(strStart, strEnd);\n                    return [length, obisID, groupMask, stringBuffer];\n                }\n            }\n        }\n        return [length];\n    }\n    return [];\n}\n\nfunction resolveObisID(groupMask, bytes, obisIDIndex, pos) {\n    var obisIDLength = 0;\n    for (var maskBit = OBIS_ID_GROUP_A; maskBit >= OBIS_ID_GROUP_F; maskBit >>= 1) {\n        if ((groupMask & maskBit) == maskBit) {\n            obisIDLength = obisIDLength + 1;\n        }\n    }\n    if (bytes.length > pos + 1 + obisIDLength + 1) {\n        var obisID = \"\";\n        var i = 0;\n        for (var maskBit = OBIS_ID_GROUP_A; maskBit >= OBIS_ID_GROUP_F; maskBit >>= 1) {\n            var value = \"X\";\n            if ((groupMask & maskBit) == maskBit) {\n                var valueNum = (bytes[pos + obisIDIndex + (i++)] & 0xFF);\n                value = valueNum.toString(10);\n            }\n            obisID = obisID + value;\n            if (maskBit > OBIS_ID_GROUP_F) {\n                obisID = obisID + OBIS_ID_DELIMITER;\n            }\n        }\n        return { 'obisIDLength': obisIDLength, 'obisID': obisID };\n    }\n    return { 'obisIDLength': 0, 'obisID': null };\n}\n\nfunction getInt64(bytes, index, length) {\n    var value = 0;\n    if ((index + length) <= bytes.length) {\n        if ((bytes[index] & 0x80) == 0x80) {\n            value = -1;\n        }\n        for (var i = 0; i < length; i++) {\n            value = value * 256;\n            value = value + (bytes[index] & 0xFF);\n            index = index + 1;\n        }\n    }\n    return value;\n}\n\nfunction extract_value_from_object_string_value(stringValue) {\n    var andSign = \"&\";\n    if (stringValue.indexOf(andSign) != -1) {\n        return null;\n    }\n    var unitDivider = \"*\";\n    var pos = stringValue.indexOf(unitDivider);\n    if (pos != -1) {\n        var unit = stringValue.slice(pos + 1);\n        var valueStringPart = stringValue.slice(0, pos);\n        var value = valueStringPart;\n        if (value != null) {\n            return [value, unit];\n        }\n    } else {\n        var value = stringValue;\n        if (value != null) {\n            return [value];\n        }\n    }\n    return null;\n}\n\nfunction buffer_to_ascii(bytes) {\n    var str = \"\";\n    for (var n = 0; n < bytes.length; n++) {\n        var b = (bytes[n] & 0xFF);\n        if (b < 0x21) {\n            return \"\";\n        }\n        str = str + String.fromCharCode(b);\n    }\n    return str;\n}\n\nfunction buffer_to_hex_string(bytes) {\n    var str = \"\";\n    for (var n = 0; n < bytes.length; n++) {\n        var part = intToHex(bytes[n] & 0xFF);\n        if (part.length() < 2) {\n            part = \"0\" + part;\n        }\n        str = str + part;\n        if (n + 1 < bytes.length) {\n            str = str + \"-\";\n        }\n    }\n    return str;\n}\n\nfunction resolveUnit(unit) {\n    if (dlmsUnits[unit] != null) {\n        return dlmsUnits[unit];\n    }\n    return unit.toString();\n}\n\nvar ERROR_STATUS_PAYLOAD = \"ERROR: unable to decode status: hex \";\n\nvar SYSTEM_TIME_FIELD_POS = 0;\nvar SYSTEM_TIME_FIELD_SIZE = 4;\nvar FIRMWARE_VERSION_MINOR_POS = 4;\nvar FIRMWARE_VERSION_MAJOR_POS = 5;\nvar LAST_SYNC_TIME_FIELD_POS = 6;\nvar LAST_SYNC_TIME_FIELD_SIZE = 4;\nvar RESET_COUNTER_FIELD_POS = 10;\nvar RESET_COUNTER_FIELD_SIZE = 4;\nvar STATUS_BITS_FIELD_POS = 14;\nvar STATUS_BITS_FIELD_SIZE = 2;\nvar CORRECT_RECEIVED_METER_FILES_FIELD_POS = 16;\nvar CORRECT_RECEIVED_METER_FILESFIELD_SIZE = 4;\nvar INCORRECT_RECEIVED_METER_FILES_FIELD_POS = 20;\nvar INCORRECT_RECEIVED_METER_FILESFIELD_SIZE = 4;\nvar UPLOADED_METER_MESSAGES_FIELD_POS = 24;\nvar UPLOADED_METER_MESSAGES_FIELD_SIZE = 4;\nvar RESERVED_1_3_POS = 28;\nvar RESERVED_1_3_SIZE = 1;\nvar STATUS_SIZE_1_0 = UPLOADED_METER_MESSAGES_FIELD_POS + UPLOADED_METER_MESSAGES_FIELD_SIZE;\nvar STATUS_SIZE_1_3 = RESERVED_1_3_POS + RESERVED_1_3_SIZE;\n\nvar LORAWAN_ACTIVATED_STATE_STATUS_BIT_MASK = 1 << 0;\nvar NETWORK_TIME_SYNCHRONIZATION_STATE_STATUS_BIT_MASK = 1 << 1;\nvar SYSTEM_TIME_SYNCHRONIZATION_STATE_STATUS_BIT_MASK = 1 << 2;\nvar OTAA_PROCEDURE_STATE_STATUS_BIT_MASK = 1 << 3;\nvar LORAWAN_CONFIGURATION_STATE_STATUS_BIT_MASK = 1 << 4;\nvar CALENDAR_EVENT_LIST_CONFIGURATION_STATE_STATUS_BIT_MASK = 1 << 6;\nvar OBIS_ID_FILTER_LIST_CONFIGURATION_STATE_STATUS_BIT_MASK = 1 << 7;\n\nvar STATUS_PRE_STRING = \"Status_\";\nvar STATUS_TIME_NAME = STATUS_PRE_STRING + \"Time\";\nvar STATUS_FIRMWARE_VERSION_NAME = STATUS_PRE_STRING + \"Firmware_Version\";\nvar STATUS_LAST_SYNC_TIME_NAME = STATUS_PRE_STRING + \"Last_Sync_Time\";\nvar STATUS_RESET_COUNTER_NAME = STATUS_PRE_STRING + \"Reset_Counter\";\nvar STATUS_LORAWAN_STATUS_NAME = STATUS_PRE_STRING + \"LoRaWAN_Activation_State\";\nvar STATUS_NETWORK_TIME_STATUS_NAME = STATUS_PRE_STRING + \"Network_Time_State\";\nvar STATUS_SYSTEM_TIME_STATUS_NAME = STATUS_PRE_STRING + \"System_Time_State\";\nvar STATUS_OTAA_PROCEDURE_STATUS_NAME = STATUS_PRE_STRING + \"OTAA_Procedure_State\";\nvar STATUS_LORAWAN_CONFIGURATION_STATUS_NAME = STATUS_PRE_STRING + \"LoRaWAN_Configuration_State\";\nvar STATUS_CALENDAR_EVENT_STATUS_NAME = STATUS_PRE_STRING + \"Calendar_Event_List_State\";\nvar STATUS_OBIS_ID_FILTER_LIST_STATUS_NAME = STATUS_PRE_STRING + \"OBIS_ID_Filter_List_State\";\nvar STATUS_CORRECT_RECEIVED_METER_FILES_COUNTER_NAME = STATUS_PRE_STRING + \"Correct_Received_Meter_Files_Counter\";\nvar STATUS_INCORRECT_RECEIVED_METER_FILES_COUNTER_NAME = STATUS_PRE_STRING + \"Incorrect_Received_Meter_Files_Counter\";\nvar STATUS_UPLOADED_METER_DATA_MESSAGES_COUNTER_NAME = STATUS_PRE_STRING + \"Uploaded_Meter_Data_Messages_Counter\";\nvar STATUS_RESERVED_1_3_NAME = STATUS_PRE_STRING + \"Reserved_V1.3\";\n\nvar FirmwareTypeMap = {\n    0:  'Release',\n    1:  'Field Test Beta Version'\n};\n\nfunction decodeStatusPayload(bytes) {\n    var attributes = {};\n    var telemetry  = {};\n    attributes[INFO_LOG_NAME] = [];\n\n    if (bytes.length >= STATUS_SIZE_1_0) {\n        var systemTimeBuf = bytes.slice(SYSTEM_TIME_FIELD_POS, SYSTEM_TIME_FIELD_POS + SYSTEM_TIME_FIELD_SIZE);\n        var minorVer = (bytes[FIRMWARE_VERSION_MINOR_POS] & 0xFF);\n        var majorVer = (bytes[FIRMWARE_VERSION_MAJOR_POS] & 0xFF);\n        var lastSyncBuf = bytes.slice(LAST_SYNC_TIME_FIELD_POS, LAST_SYNC_TIME_FIELD_POS + LAST_SYNC_TIME_FIELD_SIZE);\n        var resetCounterBuf = bytes.slice(RESET_COUNTER_FIELD_POS, RESET_COUNTER_FIELD_POS + RESET_COUNTER_FIELD_SIZE);\n        var statusBitsBuf = bytes.slice(STATUS_BITS_FIELD_POS, STATUS_BITS_FIELD_POS + STATUS_BITS_FIELD_SIZE);\n        var correctBuf = bytes.slice(CORRECT_RECEIVED_METER_FILES_FIELD_POS, CORRECT_RECEIVED_METER_FILES_FIELD_POS + CORRECT_RECEIVED_METER_FILESFIELD_SIZE);\n        var incorrectBuf = bytes.slice(INCORRECT_RECEIVED_METER_FILES_FIELD_POS, INCORRECT_RECEIVED_METER_FILES_FIELD_POS + INCORRECT_RECEIVED_METER_FILESFIELD_SIZE);\n        var uploadedBuf = bytes.slice(UPLOADED_METER_MESSAGES_FIELD_POS, UPLOADED_METER_MESSAGES_FIELD_POS + UPLOADED_METER_MESSAGES_FIELD_SIZE);\n\n        var epoch1 = (\n            ((systemTimeBuf[0] & 0xFF) << 24) |\n            ((systemTimeBuf[1] & 0xFF) << 16) |\n            ((systemTimeBuf[2] & 0xFF) << 8)  |\n            ( systemTimeBuf[3] & 0xFF)\n        ) >>> 0;\n        var systemTimeStr = new Date(epoch1 * 1000).toString();\n\n        var epoch2 = (\n            ((lastSyncBuf[0] & 0xFF) << 24) |\n            ((lastSyncBuf[1] & 0xFF) << 16) |\n            ((lastSyncBuf[2] & 0xFF) << 8)  |\n            ( lastSyncBuf[3] & 0xFF)\n        ) >>> 0;\n        var lastSyncTimeStr = new Date(epoch2 * 1000).toString();\n\n        var resetCounter = (\n            ((resetCounterBuf[0] & 0xFF) << 24) |\n            ((resetCounterBuf[1] & 0xFF) << 16) |\n            ((resetCounterBuf[2] & 0xFF) << 8)  |\n            ( resetCounterBuf[3] & 0xFF)\n        ) >>> 0;\n        var statusBits      = ((statusBitsBuf[0] & 0xFF) | ((statusBitsBuf[1] & 0xFF) << 8));\n        var correctCounter  = (\n            ((correctBuf[0] & 0xFF) << 24) |\n            ((correctBuf[1] & 0xFF) << 16) |\n            ((correctBuf[2] & 0xFF) << 8)  |\n            ( correctBuf[3] & 0xFF)\n        ) >>> 0;\n        var incorrectCounter= (\n            ((incorrectBuf[0] & 0xFF) << 24) |\n            ((incorrectBuf[1] & 0xFF) << 16) |\n            ((incorrectBuf[2] & 0xFF) << 8)  |\n            ( incorrectBuf[3] & 0xFF)\n        ) >>> 0;\n        var uploadedCounter = (\n            ((uploadedBuf[0] & 0xFF) << 24) |\n            ((uploadedBuf[1] & 0xFF) << 16) |\n            ((uploadedBuf[2] & 0xFF) << 8)  |\n            ( uploadedBuf[3] & 0xFF)\n        ) >>> 0;\n        \n        attributes[STATUS_TIME_NAME] = systemTimeStr;\n        attributes[STATUS_FIRMWARE_VERSION_NAME] = majorVer + \".\" + minorVer;\n        attributes[STATUS_LAST_SYNC_TIME_NAME] = lastSyncTimeStr;\n        attributes[STATUS_RESET_COUNTER_NAME] = resetCounter;\n        attributes[STATUS_CORRECT_RECEIVED_METER_FILES_COUNTER_NAME] = correctCounter;\n        attributes[STATUS_INCORRECT_RECEIVED_METER_FILES_COUNTER_NAME] = incorrectCounter;\n        attributes[STATUS_UPLOADED_METER_DATA_MESSAGES_COUNTER_NAME] = uploadedCounter;\n\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            LORAWAN_ACTIVATED_STATE_STATUS_BIT_MASK,\n            STATUS_LORAWAN_STATUS_NAME,\n            \"not activated\", \"activated\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            NETWORK_TIME_SYNCHRONIZATION_STATE_STATUS_BIT_MASK,\n            STATUS_NETWORK_TIME_STATUS_NAME,\n            \"not synchronized\", \"synchronized\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            SYSTEM_TIME_SYNCHRONIZATION_STATE_STATUS_BIT_MASK,\n            STATUS_SYSTEM_TIME_STATUS_NAME,\n            \"not synchronized\", \"synchronized\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            OTAA_PROCEDURE_STATE_STATUS_BIT_MASK,\n            STATUS_OTAA_PROCEDURE_STATUS_NAME,\n            \"OTAA procedure active\", \"OTAA procedure not active\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            LORAWAN_CONFIGURATION_STATE_STATUS_BIT_MASK,\n            STATUS_LORAWAN_CONFIGURATION_STATUS_NAME,\n            \"not available\", \"available\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            CALENDAR_EVENT_LIST_CONFIGURATION_STATE_STATUS_BIT_MASK,\n            STATUS_CALENDAR_EVENT_STATUS_NAME,\n            \"is empty\", \"contains at least one item\"\n        );\n        attributes = analyzeBitsToResultString(\n            attributes, statusBits,\n            OBIS_ID_FILTER_LIST_CONFIGURATION_STATE_STATUS_BIT_MASK,\n            STATUS_OBIS_ID_FILTER_LIST_STATUS_NAME,\n            \"is empty\", \"contains at least one item\"\n        );\n\n        if (bytes.length >= STATUS_SIZE_1_3) {\n            var reserved = (bytes[RESERVED_1_3_POS] & 0xFF);\n            attributes[STATUS_RESERVED_1_3_NAME] = reserved;\n        }\n\n    } else {\n        return logDecodeError(\n            { attributes: attributes, telemetry: telemetry },\n            bytes, 0, [], ERROR_STATUS_PAYLOAD\n        );\n    }\n\n    return {\n        attributes: attributes,\n        telemetry: telemetry\n    };\n}\n\nfunction resolveFirmwareType(type) {\n    if (FirmwareTypeMap[type] != null) {\n        return FirmwareTypeMap[type];\n    }\n    return \"unknown\";\n}\n\nfunction analyzeBitsToResultString(results, bits, mask, propertyName, setString, notSetString) {\n    if ((bits & mask) == mask) {\n        results[propertyName] = setString;\n    } else {\n        results[propertyName] = notSetString;\n    }\n    return results;\n}\n\nfunction modulo(a, b) {\n    return a - Math.floor(a / b) * b;\n}\n\nfunction ToUint32(x) {\n    return modulo(x, Math.pow(2, 32));\n}\n\n\nvar result = {};\n\nif (payload != null && payload.length > 0) {\n    result = decodePayload(payload);\n}\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "eui",
      "devAddr",
      "fPort",
      "bandwidth",
      "spreadingFactor",
      "codeRate",
      "frequency",
      "tenantId"
    ],
    "type": "DEVICE",
    "name": "iOKE868 $eui",
    "profile": "$applicationId",
    "label": "$deviceId",
    "customer": "",
    "group": "",
    "telemetry": null,
    "attributes": [
      "eui",
      "devAddr",
      "fPort",
      "bandwidth",
      "codeRate",
      "frequency",
      "tenantId",
      "applicationId",
      "spreadingFactor",
      "deviceId",
      "joinEui",
      "netId",
      "clusterId",
      "clusterAddress"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false,
  "converterVersion": 2
}